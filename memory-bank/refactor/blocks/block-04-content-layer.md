# Блок 4 — Content Layer (модульный контент + сборка в `GameContent`)

## Цель блока
Разорвать текущую связь “домен/редьюсер напрямую импортит `src/data/*`” и прийти к модели, где:
- контент хранится **модульно** (по фичам),
- но для игры собирается в единый **`GameContent` контейнер**,
- можно легко переключать **наборы контента** (основной/сюжетный/ивент/тест‑баланс),
- домен остаётся “чистым” и не знает, откуда контент берётся.

## Зафиксировано по ответам
- Нужны **несколько наборов контента** и переключение между ними → нужен контейнер/пакеты.
- Мышление “модулями” → контент удобнее хранить **по фичам**, чтобы не было “одного мешка”.
- “Взять только проклятия” — пока не критично → делаем так, чтобы это было возможно без лишней боли, но не усложняем.

## Выбранный подход (гибрид)
### 1) Контент хранится по фичам (модули)
Пример (понятийно):
- `src/content/spells/*`
- `src/content/curses/*`
- `src/content/monsters/*` (абилки/лейблы/группы)
- (позже) `src/content/rooms/*`, `src/content/rewards/*`, `src/content/shop/*`

Каждый модуль экспортирует определения и типы “наружу”, но без привязки к UI.

### 2) Сборка в единый контейнер `GameContent`
Есть “сборщик”:
- `createGameContent(pack: ContentPackId | ContentPackConfig): GameContent`

`GameContent` (как структура) содержит:
- `spellsById`
- `cursesById`
- `monsterAbilitiesById`
- и т.п.

### 3) Пакеты контента (Content Packs)
Пакет — это “набор включённых модулей/оверрайдов”:
- `base` (основной)
- `story` (сюжетный)
- `event` (ивент)
- `balance_test` (тестовый)

Пакеты могут:
- включать/выключать части контента,
- переопределять параметры (например, баланс значений),
- добавлять новые сущности (новые проклятия/заклинания/комнаты).

## Границы слоёв (важно для Clean Architecture)
- **Domain** видит только **интерфейсы/типы** контента (например `SpellDefinition`, `CurseDefinition`), но не импортит `src/content/*`.
- **Application (GameSession/use-cases)** получает `GameContent` как зависимость.
- **UI** не лезет в контент напрямую (кроме отображения в пикерах/энциклопедии), а берёт его через application/контейнер, чтобы не плодить обходные пути.

## План миграции (маленькими порциями)
### Шаг 4.1 — Ввести типы “Definition” и контейнер `GameContent`
- Определить контракты:
  - `SpellDefinition`
  - `CurseDefinition`
  - `MonsterAbilityDefinition`
- Определить `GameContent` структуру.

### Шаг 4.2 — Создать сборщик `createGameContent()`
- Сборщик строит мапы `byId` и делает валидации (уникальность id, обязательные поля).
- Добавить русские комментарии: что это “content layer” и зачем он нужен.

### Шаг 4.3 — Мигрировать первый модуль контента (например curses)
- Перенести `src/data/curses.ts` → `src/content/curses/*`
- UI `CursePicker` получает список из `GameContent`, а не из прямого импорта.

### Шаг 4.4 — Подключить `GameContent` в application слой
- `GameSession` получает `content` (и дальше use-cases используют его).
- Удаляем прямые импорты `CURSES/SPELLS/MONSTER_ABILITIES` из домена/редьюсера (по одному).

### Шаг 4.5 — Добавить второй/третий модуль (spells, abilities)
- Повторяем паттерн, пока `src/data/*` не перестанет быть критическим.

## Риски
- Много правок импортов.
  - Снижение: мигрировать по одному модулю (сначала `curses`, потом `spells`, потом `monsterAbilities`).
- UI может начать “тянуть контент напрямую”.
  - Снижение: контент отдаём через application/контейнер, а UI получает только то, что нужно для отображения.

## Критерии готовности (DoD)
- Domain не импортит `src/data/*` / `src/content/*` напрямую.
- Есть `GameContent` + сборщик `createGameContent`.
- Есть минимум 1 пакет контента (`base`) и возможность добавить второй (заготовка).

## Уточняющие вопросы (можно позже, можно “не знаю”)
1) Как ты хочешь выбирать пакет: из UI (настройка/декбилдер) или это dev‑флаг?
2) Пакет влияет только на контент или также на правила (механику)?

## Зафиксировано по ответам (на сейчас)
- Выбор пакета **в идеале через UI**, но **не обязательно сразу**.
- На ранних этапах можно выбрать пакет dev‑флагом/конфигом, а позже добавить UI.
- Текущие **шаблоны (templates)** уже частично решают задачу “набора/конфигурации” и могут быть переходным механизмом для content packs.
- Вопрос “пакет влияет только на контент или ещё и на механику” — пока **неизвестно**; планируем как расширение.


