# Блок 2 — Game Application Layer (GameSession / use-cases)

## Цель блока
Ввести application‑слой для игры так, чтобы:
- UI вызывал **понятные команды** (use-cases), а не “сырые action’ы”,
- появилась **долгоживущая GameSession**, которая может жить **между внутриигровыми экранами** (сюжет/комната/пауза),
- при этом мы всё ещё не переписываем весь UI и не меняем механику (миграция плавная).

## Scope
### Делаем
- Создаём `features/game/application/` и вводим фасад **`GameSession`**:
  - методы: `startGame`, `takeCardToHand`, `interactWithMonster`, `useSpellOnTarget`, `sellItem`, `resetHand`, `activateCurse`, …
  - внутри: вызывает domain reducer / domain функции.
- Добавляем явную команду “выход из боя”, потому что бой может завершаться принудительно при навигации:
  - кандидат: `exitCombat(reason?: 'navigate' | 'pause' | 'story' | ...)`
- Решаем “где живёт состояние сессии”, чтобы оно **не умирало при размонтировании экрана**:
  - вариант: `GameSessionStore` (минимальный store/контейнер) на уровне `src/app/` или `features/game/application/`.
- Делам **тонкий адаптер** для UI:
  - UI по-прежнему может использовать `useReducer` на переходный период,
  - но постепенно переключается на `session.command(...)`.

### Не делаем
- Не делаем сохранения/реплеи в этом блоке (только закладываем точки расширения).
- Не переносим контент‑слой (data/spells/curses/abilities) — это Блок 4.
- Не делаем большую декомпозицию `GameScreen` — это Блок 3.
- Детализацию внутриигровой навигации держим отдельным мини‑планом: `memory-bank/refactor/blocks/block-02a-in-game-navigation.md`.

## Главная развилка (решение, но можно отложить на конец блока)
### Где хранится `GameState`?
1) **Внутри GameSession (класс/объект) + подписки**  
   Подходит для будущих сохранений/реплеев, но потребует аккуратной интеграции с React.
2) **В React (useReducer), а GameSession только генерит “следующее состояние”**  
   Самый безопасный переход: GameSession = “команды → action/reducer”.
3) **В отдельном store (Zustand или минимальный кастомный)**  
   Хорошо для “между экранами”, но требует дисциплины, чтобы store не стал новым “бог‑объектом”.

**Безопасный дефолт для начала:** (2) → затем перейти к (3), когда будет понятно, какие экраны шарят state.

## План миграции (маленькими порциями)
### Шаг 2.1 — Ввести интерфейс GameSession и “контейнер жизненного цикла”
- Создать `GameSession` (пока тонкий фасад над reducer).
- Создать место, где он живёт между экранами (контейнер/провайдер/хранилище).
- Добавить русские комментарии: что это application слой и зачем.

### Шаг 2.2 — Добавить 1–2 use-case как пример (вертикальный срез)
Например:
- `startGame(...)`
- `takeCardToHand(...)`

Цель — показать паттерн, не переписывая всё.

### Шаг 2.3 — Подключить UI к GameSession минимально
- `GameScreen` начинает вызывать `session.startGame()` и/или `session.takeCardToHand()` через адаптер.
- Остальные действия пока остаются старым способом (до следующей итерации).

### Шаг 2.4 — Расширять покрытие use-cases
Постепенно переносим остальные команды, пока UI перестанет работать напрямую с action’ами.

## Риски
- **Риск:** усложнение без выгоды, если сделать слишком “умную” GameSession слишком рано.
  - **Снижение:** идти вертикальными срезами (2 команды → проверить → дальше).
- **Риск:** state начнёт “дублироваться” (и в reducer, и в session/store).
  - **Снижение:** выбирать один источник правды на каждом шаге.

## Критерии готовности (DoD)
- Есть `GameSession` как единая точка команд.
- Сессия может жить **между экранами** (не сбрасывается при переходах).
- Минимум 1–2 команды реально работают через session.
- Поведение игры не менялось (только путь вызовов).

## Чеклист регресса (ручной)
- Начать игру → сделать 2–3 действия → перейти на другой **внутриигровой** экран → вернуться → состояние сохранилось.
- При внутриигровых переходах игра не “перезапускается”.
- При выходе в **главное меню** сессию можно завершать (Resume из меню не обязателен на этом этапе).

## Документация
- `memory-bank/refactor/plan-v1.md` — если уточнили окончательный вариант “где живёт state”.
- Если затрагиваем библиотеки (например, Zustand/React patterns) — использовать **Context7** для актуальных рекомендаций.


