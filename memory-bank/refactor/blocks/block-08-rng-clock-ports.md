# Блок 8 — RNG/Clock порты (под тестируемость, сохранения и реплеи)

## Цель блока
Подготовить игру к будущим “сохранениям / реплеям / детерминированным забегам” и упростить тестирование, вынеся источники недетерминизма из доменной логики:
- `Math.random()` → **RNG port**
- `Date.now()` → **Clock port**

При этом внедрение должно быть **минимальным и безопасным**: сначала только “инъекция зависимости”, без изменения механики.

## Почему это важно
Без RNG/Clock портов сложно:
- воспроизводить баги (“у меня выпало иначе”),
- писать стабильные тесты,
- делать реплеи/сиды (“один и тот же забег при одинаковом seed”),
- корректно сериализовать события/таймстемпы.

## Scope
### Делаем
- Вводим интерфейсы (порты) `Rng` и `Clock`.
- Определяем **дефолтные реализации** (обёртки над `Math.random` и `Date.now`).
- Подключаем их в application‑слой (`GameSession`) как зависимости.
- В домене заменяем прямые вызовы `Math.random/Date.now` на вызовы `rng/clock` **по мере необходимости**.

### Не делаем
- Не реализуем полноценные реплеи/сиды в этом блоке (только фундамент).
- Не меняем баланс/механику (никаких “новых рандомов”).

## Предлагаемые интерфейсы (концептуально)
### RNG
- `nextFloat()` → число 0..1
- (опционально) `nextInt(maxExclusive)` → 0..maxExclusive-1
- (опционально) `pickIndex(length)` / `shuffle(array)`

### Clock
- `now()` → number (ms)

## Где это живёт (границы)
- Порты (`Rng`, `Clock`) — в **domain ports** (или в `features/game/domain/ports`, если пойдём по features‑структуре).
- Реализации:
  - “дефолтные” (Math/Date) можно держать в application или infrastructure (зависит от того, как ты хочешь классифицировать `Date/Math`; чаще это “infrastructure-ish”).
- `GameSession` получает `rng/clock` как зависимости и прокидывает в доменные функции.

## План миграции (маленькими порциями)
### Шаг 8.1 — Добавить порты и дефолтные реализации
- `Rng`, `Clock`
- `DefaultRng`, `DefaultClock`
- Русские комментарии: зачем и где используется.

### Шаг 8.2 — Инъекция в `GameSession`
- `GameSession` принимает `{ rng, clock }` (с дефолтами).
- UI пока ничего не знает: в composition root создаём session с дефолтами.

### Шаг 8.3 — Заменить “критичные” места в домене
Начинаем с тех мест, где рандом реально влияет на поведение и тестируемость:
- тасовка колоды
- выбор случайных карт/слотов (например, Fog)
- генерация id (если хотим детерминированные id в реплее — отдельный порт `IdGenerator`, опционально)

### Шаг 8.4 — (Опционально) подготовить seeded RNG
Если появится потребность в “seeded runs”:
- добавить реализацию `SeededRng(seed)` (и определить алгоритм)
- зафиксировать, где хранится seed (в run config / save)

## Риски
- Легко начать “перетаскивать” слишком много изменений за раз.
  - Снижение: сначала только интерфейсы и инъекция в `GameSession`, затем точечно менять вызовы.
- Несовпадение ожиданий: “время” иногда нужно реальное (лог/анимации).
  - Снижение: clock используем для доменных таймстемпов; UI-анимации могут жить своей жизнью.

## Критерии готовности (DoD)
- В доменной логике нет прямых `Math.random/Date.now` (или они сведены к минимуму и помечены).
- `GameSession` принимает `rng/clock` и может работать с дефолтами.
- Есть понятные комментарии на русском, что это фундамент под реплеи/сохранения.

## Уточняющие вопросы (можно “не знаю”)
1) Хотим ли мы “seeded runs” как часть UI (например, dev‑режим) или только внутренне?
2) Нужно ли делать “детерминированные id” (тогда добавим порт `IdGenerator`)?

## Зафиксировано по ответам (на сейчас)
- “Seeded runs” как dev‑фича **пока не важно** → реализацию `SeededRng` откладываем до момента реальной потребности.
- Детерминированные `id` для реплеев **пока не важно** → порт `IdGenerator` не вводим сейчас (оставляем как возможное расширение).


