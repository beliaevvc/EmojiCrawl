# Под‑блок 2A — Внутриигровая навигация (Variant A: `inGameView` state)

## Цель
Сделать “внутриигровые экраны” (сюжет/комнаты/награды/магазин/пауза) без внедрения полноценного роутера и без ломки `App.tsx`, при этом:
- состояние забега не сбрасывается при переходах между внутриигровыми экранами,
- переходы понятные и расширяемые,
- “Resume после F5” **не делаем сейчас** (это будущая задача).

## Выбранный подход
**Вариант A — внутренний роутер на состоянии:**
- вводим `inGameView` (например: `'combat' | 'story' | 'room_select' | 'rewards' | 'shop' | 'pause'`)
- внутри “игрового флоу” есть простой switch/маппинг: какой экран показывать
- `App.tsx` по‑прежнему знает только “menu / game / stats / deckbuilder”

## Набор экранов v0 (можно менять позже)
- `combat` — бой
- `story` — сюжет/диалоги/текст
- `room_select` — выбор следующей комнаты
- `rewards` — награды после комнаты
- `shop` — магазин
- `pause` — пауза/меню забега

## Правила переходов (черновик, “логично и просто”)
### 1) Бой — это отдельная сцена
- По твоему решению (вариант **B**): игрок может выйти из боя **в середине**, и это **принудительно завершает боевой контекст**.
  - переход из `combat` → `story/rewards/room_select/shop` означает “закрываем боевой контекст” (детали позже уточним).
- Важно: это не означает “сбрасывать весь забег” — речь только про завершение текущего “боевого куска”.

**Следствие для архитектуры:** нужен явный use-case/команда уровня application, например `exitCombat()`, чтобы “закрытие боя” было централизованным и не размазывалось по UI.

### 2) Кнопка “назад” разрешена
- Переходы назад **не запрещены**.
- Чтобы это работало предсказуемо, добавляем простой стек навигации:
  - `inGameHistory: InGameView[]` (push при переходе)
  - `goBack()` возвращает на предыдущий экран

### 3) Модалки и отдельные экраны — оба варианта допустимы
- `pause` может быть:
  - либо модалкой поверх текущего экрана (проще, не ломает контекст),
  - либо отдельным `inGameView='pause'` (если захочется “полноэкранную паузу”).
- “Правила/настройки”:
  - чаще удобнее как модалки,
  - но иногда как отдельный экран (например, в сюжетном режиме).

## Где живёт состояние (в связке с Блоком 2)
Цель: состояние не должно умирать при размонтировании текущего экрана.

**Дефолт‑вариант для начала:**
- `GameSession` живёт в “игровом флоу” (например, в контейнере/провайдере уровня `game`‑ветки).
- `inGameView` и `inGameHistory` живут рядом с `GameSession` (application слой), чтобы навигация и состояние были согласованы.

## План работ (маленькими порциями)
1) Ввести `InGameView` тип + перечисление экранов v0.
2) Добавить `inGameView` + `navigate(to)` + `goBack()` + `history` (минимально).
3) Подключить 2 экрана как прототип (например `combat` и `pause`), проверить, что состояние не теряется.
4) Добавлять остальные экраны по мере появления контента.

## Риски
- “Бой заканчивается при выходе” нужно будет формализовать: что именно значит “закончился” (результат, награды, очистка поля, переход к следующей комнате).
  - Это нормально: уточним в момент, когда появится первый сюжет/комната.

## Критерии готовности (DoD)
- Можно переключаться минимум между `combat` ↔ `pause` без сброса состояния забега.
- Есть `goBack()` и он работает предсказуемо.
- `App.tsx` не усложнился (по‑прежнему не знает детали внутриигровых экранов).

## Чеклист регресса (ручной)
- В бою сделать 1–2 действия → открыть паузу → закрыть → бой в том же состоянии.
- Перейти на другой внутриигровой экран → вернуться “назад” → состояние забега сохранено.


