# План рефакторинга архитектуры (V1): «Clean Architecture для Skazmor Playtest»

## Статус (V1)
**План V1 реализован.** Все блоки из `memory-bank/refactor/roadmap-v1.md` выполнены (0–6, 8, 90), архитектура и документация приведены к фактическому состоянию.

Актуальный чекпойнт состояния — `memory-bank/activeContext.md`, подробная хронология — `memory-bank/progress.md`.

## Зачем этот документ
Это **первый план “создания дальнейших планов”** для большого рефакторинга.  
Он задаёт:
- **целевую архитектуру** (слои, границы, правила зависимостей),
- **блоки миграции** (небольшими партиями, без поломок),
- **шаблон мини‑планов** для каждого блока,
- **критерии готовности** и “предохранители” (чтобы рефакторинг был безопасным).

Документ будет улучшаться итерациями (V2, V3…), а реализация будет идти **по блокам**, каждый из которых имеет свой мини‑план.

**Roadmap (порядок внедрения):** `memory-bank/refactor/roadmap-v1.md`

---

## 1) Текущее состояние (срез по коду)
> Примечание: этот раздел фиксирует **исходное состояние до рефакторинга V1** (как было “в начале пути”).  
> Текущее состояние проекта см. в `memory-bank/activeContext.md`.

### 1.1. Где сейчас “ядро игры”
- **Доменная логика** фактически сосредоточена в `src/utils/gameReducer.ts` (большой редьюсер + хелперы) и `src/utils/gameLogic.ts` (создание/перемешивание колоды).
- **Модели** лежат в `src/types/game.ts`.
- **Контент/баланс** лежит в `src/data/*` и прямо импортится в редьюсер (`SPELLS`, `MONSTER_ABILITIES`, `CURSES`).
- **UI** крупными монолитами:
  - `src/components/GameScreen.tsx` — огромный экран: DnD, окно логов, статы, модалки, баннеры, оверлеи, хуки, плюс glue‑код действий.
  - `src/components/DeckbuilderScreen.tsx` — тоже экран + модалки + логика.

### 1.2. Где сейчас инфраструктура
- `src/lib/supabase.ts` — Supabase client.
- `src/stores/*` — Zustand сторы, в некоторых есть **прямые вызовы Supabase** (например, `useWalletStore`) и подписки (`useAuthStore`).
- `src/utils/*Storage.ts` — LocalStorage (run history, ui state, templates).

### 1.3. Основные “узлы боли”
- **Монолитность экранов** → тяжело менять/собирать новые сценарии.
- **Смешение домена и контента** (редьюсер импортит `data/*`) → домен не изолирован.
- **Недетерминизм в домене** (`Math.random`, `Date.now`) → тяжело тестировать/воспроизводить.
- **Инфраструктура внутри Zustand** → сложно менять бекенд/кэш/репозитории.
- `skazmor-app/`: **не участвует в текущей сборке** (точка входа `index.html` → `/src/main.tsx`, `tsconfig.json` включает только `src`, импортов `skazmor-app` в рабочем коде нет). Вероятно архив/прототип, но лучше помечать как **архивный/неиспользуемый**, а не “точно устаревший”, пока ты сам не подтвердил, что он больше не нужен.

---

## 2) Цели и принципы (что считаем “хорошо”)

## 2.0. Зафиксированные решения и открытые вопросы (на текущий момент)
### Принято
- **Плавная миграция через временные ре‑экспорты — разрешена** (например, `src/utils/gameReducer.ts`/`src/utils/gameLogic.ts` могут временно ре‑экспортить новое ядро), чтобы рефакторинг шёл без массовых правок UI.

### Открыто (можно решать итеративно)
- **Структура папок**: точная схема (`src/features/...` vs `src/domain/...`) пока не выбрана. Критерий выбора: **логичность и простота**. Дефолт‑предложение: `src/features/<feature>/{domain,application,ui}` как более “сборный” вариант для будущих экранов/сюжетов.
- **Недетерминизм (RNG/Clock)**: пока не решено, выносить ли `Math.random/Date.now` в порты на Блоке 1. Безопасный дефолт: **оставить как есть на Блоке 1**, пометить как техдолг и вынести в порты отдельным маленьким под‑блоком, когда появится потребность в тестах/реплеях.

### Уточнено (по ответам)
- **Жизненный цикл игры:** игровая сессия должна **жить между внутриигровыми экранами** (например, переходы “сюжет/комната/меню паузы” не должны убивать state). При выходе в главное меню — сессию можно считать завершённой (Resume из меню пока не обязателен).
- **Переходы из боя:** выбран вариант **B** — возможен выход из боя “в середине”, и это **принудительно завершает боевой контекст**. Значит “закрытие боя” должно быть оформлено отдельной командой/use-case (application слой), а не реализовано разрозненно в UI.
- **Сохранения/сид/реплей:** вероятно понадобятся позже → сейчас закладываем архитектурные “крючки” (GameSession как фасад, потенциальные порты `Rng/Clock`, интерфейс хранения), но не внедряем всё сразу.

### Решение по контенту (для Блока 4)
- Требование: несколько наборов контента (base/story/event/balance-test) + модульный подход.
- Выбран **гибрид**: контент хранится **по фичам**, но собирается в единый контейнер **`GameContent`** через “сборщик/registry”, чтобы можно было переключать content packs.
- Детали: `memory-bank/refactor/blocks/block-04-content-layer.md`.

**Как выбираем content pack (на сейчас):**
- В идеале — через UI, но не обязательно сразу: можно начать с dev‑флага/конфига, а затем добавить выбор в UI.
- Текущие шаблоны (templates) можно использовать как переходный механизм.

### 2.1. Цели
- **Отделить логику от UI**: ядро игры должно жить без React/DOM.
- **Сделать экраны сборными**: UI‑компоненты и “экраны” (screens) должны быть отделены, чтобы можно было собирать “сюжеты/комнаты/сценарии” из готовых блоков.
- **Декомпозировать код на логичные файлы** (меньше “бог‑файлов”).
- **Мигрировать безопасно**: рефакторинг партиями, с критериями готовности и быстрым rollback.

### 2.2. Правило зависимостей (Clean Architecture)
Внутренние слои **не знают** о внешних:
- **Domain** (ядро правил) не импортит React/Zustand/Supabase/LocalStorage.
- **Application** (use‑cases) может использовать domain, но тоже не привязана к UI.
- **UI / Frameworks** зависимы от application (hooks/controllers) и инфраструктуры.
- **Infrastructure** (Supabase/LocalStorage) реализует интерфейсы, определённые во внутренних слоях.

---

## 3) Целевая структура проекта (черновой “скелет”)

### 3.1. Папки верхнего уровня (предложение)
Мы не обязаны всё перенести сразу — это цель, к которой идём блоками.

- `src/app/` — composition root (провайдеры, роутинг/навигация, связывание фич)
- `src/features/` — фичи (bounded contexts):
  - `game/` — основной геймплей
  - `deckbuilder/` — редактор колоды
  - `stats/` — история забегов/статистика
  - `wallet/` — кошелёк/экономика
  - `auth/` — авторизация
  - `devquest/` — мета‑слой/пасхалки (можно держать отдельно, чтобы не засорял game)
- `src/shared/` — общее (UI primitives, утилиты, типы, стили, маленькие хелперы)
- `src/infrastructure/` — реализации адаптеров (supabase/localStorage/и т.п.)
- `src/content/` — статический контент/баланс (спеллы/проклятья/абилки/версии)

### 3.2. Внутри фичи (пример для `features/game/`)
- `features/game/domain/`
  - `model/` (типизации сущностей/значений: Card, Player, GameState…)
  - `rules/` (чистые правила/функции)
  - `reducer/` (если остаёмся на reducer‑подходе)
  - `ports/` (интерфейсы: RNG/Clock/Logger/Repositories — по необходимости)
- `features/game/application/`
  - use‑cases (StartGame, TakeCardToHand, InteractWithMonster…)
  - “GameSession” сервис (оркестрация domain + зависимости)
- `features/game/ui/`
  - `screens/` (GameScreen как компоновка)
  - `components/` (GameBoard, Hand, HUD, Windows…)
  - `dnd/` (обвязка react-dnd)

---

## 4) “Блоки” миграции (итеративно и безопасно)

Ниже — **первичная разбивка**. Для каждого блока мы создаём мини‑план (см. раздел 5).

### Блок 0 — Предохранители и правила (без функциональных изменений)
**Цель:** подготовить почву, чтобы следующий перенос был безопасным.
- Ввести соглашения по папкам и импорту (границы слоёв).
- (Опционально) добавить алиасы путей в `tsconfig` (`@/features/*`, `@/shared/*`).
- (Опционально) добавить лёгкие тесты для доменной логики (Vitest) **только для reducer/domain**, без UI.

**Готово когда:**
- структура/правила описаны, и есть механика контроля (хотя бы договорённость + линтер позже).

### Блок 1 — Выделение Game Domain Kernel

**Цель:** выделить минимальное “ядро игры”, которое не зависит от UI и инфраструктуры.

**Идея:** мы не “переписываем всё”, а сначала **перемещаем и нормализуем** существующий код:
- `src/types/game.ts` → становится доменной моделью (или реэкспортится из нового места).
- `src/utils/gameReducer.ts` → превращается в `features/game/domain/...` (с сохранением API).
- `src/utils/gameLogic.ts` → переезжает в домен (создание/перемешивание колоды позже выделим как use‑case).

**Особое внимание:** недетерминизм.
- В идеале домен получает зависимости:
  - `Rng` (случайность)
  - `Clock` (время)
- На первом шаге можно оставить `Math.random/Date.now`, но **зафиксировать как технический долг**, потому что тесты и воспроизводимость зависят от этого.

**Готово когда:**
- доменная логика компилируется отдельно (нет импортов React/DOM/Zustand/Supabase/LocalStorage),
- текущий UI всё ещё работает (пока через реэкспорты/тонкие обёртки),
- мы можем написать 2–3 smoke‑теста на reducer (опционально, но желательно).

### Блок 2 — Application слой: “GameSession / Use‑cases”
**Цель:** отделить “что происходит в игре” от “как UI вызывает это”.

**Что появится:**
- `features/game/application/`:
  - use‑cases: `startGame`, `takeCardToHand`, `interactWithMonster`, `useSpell`, `sellItem`, `resetHand`, `activateCurse`…
  - единая точка: `GameSession` / `GameEngine` (принимает зависимости: content + rng + clock).

**Почему это важно:**
- UI перестаёт знать детали reducer/action и начинает дергать **понятные команды**.
- В будущем “комнаты/сюжеты” будут добавляться как новые use‑cases/сценарии, а не как хаки в UI.

**Готово когда:**
- `GameScreen` использует не прямой `dispatch({type: ...})`, а thin‑adapter (или сервис), который мапит UI‑ивенты на use‑cases.

### Блок 3 — UI-декомпозиция: Screen vs Components
**Цель:** разрезать `GameScreen.tsx` на “экран‑компоновку” и набор переиспользуемых компонент.

**Кандидаты на вынос (ориентир):**
- `features/game/ui/components/`
  - `GameBoard` (поле)
  - `HandPanel` (левая/правая рука/рюкзак)
  - `HudWindows` (статы/лог/дискарды/лейблы)
  - `Overlays` (fog/darkness/flashlight/ghost/slime)
  - `Modals` (rules/settings/confirm/pickers)
- `features/game/ui/dnd/`:
  - `EnemySlotDropZone`, `SellZone`, `InteractionZone` и т.п. как отдельные компоненты/хуки.

**Суть:** `GameScreen` должен стать “склейкой” и layout’ом, а не местом, где живёт вся логика.

**Готово когда:**
- `GameScreen.tsx` значительно уменьшился (ориентир: < 300–400 строк),
- компоненты можно использовать для нового экрана/режима без копипасты.

### Блок 4 — Контент и правила (Content Layer)
**Цель:** разорвать жёсткую связку “домен импортит `src/data/*`”.

**Подход:**
- собрать контент в один “контейнер” (например, `GameContent`), который создаётся снаружи домена и передаётся внутрь application слоя.
- домен знает только интерфейсы/контракты (например, `SpellDefinition`, `CurseDefinition`), но не знает, откуда они пришли.

**Готово когда:**
- domain больше не импортит `src/data/*`,
- контент можно подменить (для тестов/режимов/баланса).

### Блок 5 — Инфраструктура: Supabase и LocalStorage через адаптеры
**Цель:** вытащить I/O из Zustand/компонентов в инфраструктурный слой с интерфейсами.

**Кандидаты:**
- `wallet`:
  - интерфейс `WalletRepository` (внутренний слой),
  - реализация `SupabaseWalletRepository` (infrastructure),
  - Zustand store становится “тонким”: дергает use‑case/репозиторий, а не содержит SQL‑like логику.
- `templates/history/ui-state`:
  - `TemplateRepository`, `RunHistoryRepository`, `UIStateRepository`
  - реализации `LocalStorage*Repository`

**Готово когда:**
- store’ы не содержат прямых `.from('wallets')...` (или хотя бы это изолировано в одном месте),
- LocalStorage доступ централизован и мокается в тестах.

**Мини‑план:** `memory-bank/refactor/blocks/block-05-infrastructure-adapters.md`.

### Блок 6 — Навигация/композиция и “мета-слой”
**Цель:** привести `App.tsx` к роли composition root + изолировать мета‑слой (dev quest / пасхалки) от game.

**Идея:**
- `App.tsx` оставляем как маршрутизатор/компоновщик, но переносим мета‑эффекты (idle, magic words, overlays) в `features/devquest` и подключаем как отдельный “плагин”.

**Готово когда:**
- геймплей можно запускать/использовать без devquest‑логики (по желанию),
- App меньше знает о деталях конкретных фич.

**Мини‑план:** `memory-bank/refactor/blocks/block-06-composition-root-and-plugins.md`.

### Блок 7 — Уборка артефактов
**Цель:** убрать шум из репо.
- `skazmor-app/` пометить как архив (или вынести из рабочего дерева), чтобы не путать новую архитектуру; перед удалением/выносом — подтвердить, что он больше не нужен как “историческая версия”.

Примечание: если папка уже удалена вручную — этот блок можно считать закрытым, а “историчность” при необходимости восстанавливать из истории VCS/бэкапов.

### Блок 90 — Ревизия документации Memory Bank (после рефакторинга)
**Цель:** после стабилизации архитектуры обновить/пересобрать `memory-bank/`, чтобы он отражал новые границы слоёв и стал удобной навигацией по проекту.

**Мини‑план:** `memory-bank/refactor/blocks/block-90-memory-bank-docs-refresh.md`.

### Блок 8 — RNG/Clock порты (под сохранения/реплеи)
**Цель:** вынести `Math.random` и `Date.now` из доменной логики через порты `Rng/Clock`, чтобы подготовить тестируемость и детерминированные забеги.

**Мини‑план:** `memory-bank/refactor/blocks/block-08-rng-clock-ports.md`.

---

## 5) Шаблон “мини‑плана” для каждого блока (то, из чего будет состоять 30% этого плана)

Для каждого блока мы создаём отдельный файл в `memory-bank/refactor/blocks/` вида:
`block-XX-<short-name>.md`

**Шаблон:**
- **Цель блока** (1–2 предложения)
- **Scope**: что точно делаем / что точно НЕ делаем
- **Затрагиваемые файлы/папки**
- **Шаги миграции** (маленькими коммит‑порциями)
- **Риски и план отката**
- **Критерии готовности (DoD)**
- **Чеклист регресса** (ручной)
- **Документация**: какие `memory-bank/*` обновляем при необходимости

---

## 6) Правила выполнения рефакторинга (чтобы не ломалось)

- Один блок = один “мини‑план” = одна серия маленьких PR/коммитов.
- После каждого шага внутри блока проект должен собираться и запускаться.
- Любое изменение игровой логики → обновляем `memory-bank/gameMechanics.md`.
- Любое изменение контента → обновляем `memory-bank/gameContent.md`.
- Любые изменения дизайн‑системы/компонентных паттернов → `memory-bank/uiDesign.md`.

### 6.1. Комментарии в коде (обязательное правило)
- **Комментарии, поясняющие “что есть что” и “почему так” — на русском языке.**
- При рефакторинге мы не просто переносим файлы: мы **добавляем понятные пояснения** к архитектурным границам:
  - что относится к **domain/application/ui/infrastructure/content**,
  - где “чистая логика”, а где адаптеры/интеграции,
  - какие инварианты/правила домена соблюдаются.
- Именование функций/переменных остаётся **на английском** (как сейчас принято), но *объяснения* — **на русском**.

### 6.2. Использование Context7 MCP для свежей документации
- Если в блоке затрагиваются сторонние библиотеки (React, Vite, Zustand, Supabase, react-dnd, framer-motion и т.д.), по возможности использовать **Context7 MCP** для получения **актуальной документации и примеров**.
- Это особенно важно для:
  - миграций/обновлений API,
  - сложных интеграций (DnD, анимации, auth),
  - нестандартных edge-case’ов.

### 6.3. Уточняющие вопросы и короткие апдейты по ходу работы
- **Уточняющие вопросы можно и нужно задавать на любом этапе и в любом количестве.**
  - Если ты не знаешь ответ — это ок; мы фиксируем “неизвестно” и выбираем безопасное предположение/вариант.
- На каждом этапе (или после 2–3 шагов) я даю **короткое, но понятное объяснение**, что делаю сейчас и зачем (без длинных простыней).

---

## 7) Что делаем следующим шагом (V1 → V1.1)

1) Утвердить **целевую структуру папок** (можно с небольшими правками под твой стиль).
2) Создать мини‑план для **Блока 0** (предохранители).
3) Создать мини‑план для **Блока 1** (domain kernel) и начать перенос без изменения поведения.


