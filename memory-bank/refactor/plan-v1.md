# План рефакторинга архитектуры (V1): «Clean Architecture для Skazmor Playtest»

## Зачем этот документ
Это **первый план “создания дальнейших планов”** для большого рефакторинга.  
Он задаёт:
- **целевую архитектуру** (слои, границы, правила зависимостей),
- **блоки миграции** (небольшими партиями, без поломок),
- **шаблон мини‑планов** для каждого блока,
- **критерии готовности** и “предохранители” (чтобы рефакторинг был безопасным).

Документ будет улучшаться итерациями (V2, V3…), а реализация будет идти **по блокам**, каждый из которых имеет свой мини‑план.

---

## 1) Текущее состояние (срез по коду)

### 1.1. Где сейчас “ядро игры”
- **Доменная логика** фактически сосредоточена в `src/utils/gameReducer.ts` (большой редьюсер + хелперы) и `src/utils/gameLogic.ts` (создание/перемешивание колоды).
- **Модели** лежат в `src/types/game.ts`.
- **Контент/баланс** лежит в `src/data/*` и прямо импортится в редьюсер (`SPELLS`, `MONSTER_ABILITIES`, `CURSES`).
- **UI** крупными монолитами:
  - `src/components/GameScreen.tsx` — огромный экран: DnD, окно логов, статы, модалки, баннеры, оверлеи, хуки, плюс glue‑код действий.
  - `src/components/DeckbuilderScreen.tsx` — тоже экран + модалки + логика.

### 1.2. Где сейчас инфраструктура
- `src/lib/supabase.ts` — Supabase client.
- `src/stores/*` — Zustand сторы, в некоторых есть **прямые вызовы Supabase** (например, `useWalletStore`) и подписки (`useAuthStore`).
- `src/utils/*Storage.ts` — LocalStorage (run history, ui state, templates).

### 1.3. Основные “узлы боли”
- **Монолитность экранов** → тяжело менять/собирать новые сценарии.
- **Смешение домена и контента** (редьюсер импортит `data/*`) → домен не изолирован.
- **Недетерминизм в домене** (`Math.random`, `Date.now`) → тяжело тестировать/воспроизводить.
- **Инфраструктура внутри Zustand** → сложно менять бекенд/кэш/репозитории.
- `skazmor-app/`: **не участвует в текущей сборке** (точка входа `index.html` → `/src/main.tsx`, `tsconfig.json` включает только `src`, импортов `skazmor-app` в рабочем коде нет). Вероятно архив/прототип, но лучше помечать как **архивный/неиспользуемый**, а не “точно устаревший”, пока ты сам не подтвердил, что он больше не нужен.

---

## 2) Цели и принципы (что считаем “хорошо”)

### 2.1. Цели
- **Отделить логику от UI**: ядро игры должно жить без React/DOM.
- **Сделать экраны сборными**: UI‑компоненты и “экраны” (screens) должны быть отделены, чтобы можно было собирать “сюжеты/комнаты/сценарии” из готовых блоков.
- **Декомпозировать код на логичные файлы** (меньше “бог‑файлов”).
- **Мигрировать безопасно**: рефакторинг партиями, с критериями готовности и быстрым rollback.

### 2.2. Правило зависимостей (Clean Architecture)
Внутренние слои **не знают** о внешних:
- **Domain** (ядро правил) не импортит React/Zustand/Supabase/LocalStorage.
- **Application** (use‑cases) может использовать domain, но тоже не привязана к UI.
- **UI / Frameworks** зависимы от application (hooks/controllers) и инфраструктуры.
- **Infrastructure** (Supabase/LocalStorage) реализует интерфейсы, определённые во внутренних слоях.

---

## 3) Целевая структура проекта (черновой “скелет”)

### 3.1. Папки верхнего уровня (предложение)
Мы не обязаны всё перенести сразу — это цель, к которой идём блоками.

- `src/app/` — composition root (провайдеры, роутинг/навигация, связывание фич)
- `src/features/` — фичи (bounded contexts):
  - `game/` — основной геймплей
  - `deckbuilder/` — редактор колоды
  - `stats/` — история забегов/статистика
  - `wallet/` — кошелёк/экономика
  - `auth/` — авторизация
  - `devquest/` — мета‑слой/пасхалки (можно держать отдельно, чтобы не засорял game)
- `src/shared/` — общее (UI primitives, утилиты, типы, стили, маленькие хелперы)
- `src/infrastructure/` — реализации адаптеров (supabase/localStorage/и т.п.)
- `src/content/` — статический контент/баланс (спеллы/проклятья/абилки/версии)

### 3.2. Внутри фичи (пример для `features/game/`)
- `features/game/domain/`
  - `model/` (типизации сущностей/значений: Card, Player, GameState…)
  - `rules/` (чистые правила/функции)
  - `reducer/` (если остаёмся на reducer‑подходе)
  - `ports/` (интерфейсы: RNG/Clock/Logger/Repositories — по необходимости)
- `features/game/application/`
  - use‑cases (StartGame, TakeCardToHand, InteractWithMonster…)
  - “GameSession” сервис (оркестрация domain + зависимости)
- `features/game/ui/`
  - `screens/` (GameScreen как компоновка)
  - `components/` (GameBoard, Hand, HUD, Windows…)
  - `dnd/` (обвязка react-dnd)

---

## 4) “Блоки” миграции (итеративно и безопасно)

Ниже — **первичная разбивка**. Для каждого блока мы создаём мини‑план (см. раздел 5).

### Блок 0 — Предохранители и правила (без функциональных изменений)
**Цель:** подготовить почву, чтобы следующий перенос был безопасным.
- Ввести соглашения по папкам и импорту (границы слоёв).
- (Опционально) добавить алиасы путей в `tsconfig` (`@/features/*`, `@/shared/*`).
- (Опционально) добавить лёгкие тесты для доменной логики (Vitest) **только для reducer/domain**, без UI.

**Готово когда:**
- структура/правила описаны, и есть механика контроля (хотя бы договорённость + линтер позже).

### Блок 1 — Выделение Game Domain Kernel

**Цель:** выделить минимальное “ядро игры”, которое не зависит от UI и инфраструктуры.

**Идея:** мы не “переписываем всё”, а сначала **перемещаем и нормализуем** существующий код:
- `src/types/game.ts` → становится доменной моделью (или реэкспортится из нового места).
- `src/utils/gameReducer.ts` → превращается в `features/game/domain/...` (с сохранением API).
- `src/utils/gameLogic.ts` → переезжает в домен (создание/перемешивание колоды позже выделим как use‑case).

**Особое внимание:** недетерминизм.
- В идеале домен получает зависимости:
  - `Rng` (случайность)
  - `Clock` (время)
- На первом шаге можно оставить `Math.random/Date.now`, но **зафиксировать как технический долг**, потому что тесты и воспроизводимость зависят от этого.

**Готово когда:**
- доменная логика компилируется отдельно (нет импортов React/DOM/Zustand/Supabase/LocalStorage),
- текущий UI всё ещё работает (пока через реэкспорты/тонкие обёртки),
- мы можем написать 2–3 smoke‑теста на reducer (опционально, но желательно).

### Блок 2 — Application слой: “GameSession / Use‑cases”
**Цель:** отделить “что происходит в игре” от “как UI вызывает это”.

**Что появится:**
- `features/game/application/`:
  - use‑cases: `startGame`, `takeCardToHand`, `interactWithMonster`, `useSpell`, `sellItem`, `resetHand`, `activateCurse`…
  - единая точка: `GameSession` / `GameEngine` (принимает зависимости: content + rng + clock).

**Почему это важно:**
- UI перестаёт знать детали reducer/action и начинает дергать **понятные команды**.
- В будущем “комнаты/сюжеты” будут добавляться как новые use‑cases/сценарии, а не как хаки в UI.

**Готово когда:**
- `GameScreen` использует не прямой `dispatch({type: ...})`, а thin‑adapter (или сервис), который мапит UI‑ивенты на use‑cases.

### Блок 3 — UI-декомпозиция: Screen vs Components
**Цель:** разрезать `GameScreen.tsx` на “экран‑компоновку” и набор переиспользуемых компонент.

**Кандидаты на вынос (ориентир):**
- `features/game/ui/components/`
  - `GameBoard` (поле)
  - `HandPanel` (левая/правая рука/рюкзак)
  - `HudWindows` (статы/лог/дискарды/лейблы)
  - `Overlays` (fog/darkness/flashlight/ghost/slime)
  - `Modals` (rules/settings/confirm/pickers)
- `features/game/ui/dnd/`:
  - `EnemySlotDropZone`, `SellZone`, `InteractionZone` и т.п. как отдельные компоненты/хуки.

**Суть:** `GameScreen` должен стать “склейкой” и layout’ом, а не местом, где живёт вся логика.

**Готово когда:**
- `GameScreen.tsx` значительно уменьшился (ориентир: < 300–400 строк),
- компоненты можно использовать для нового экрана/режима без копипасты.

### Блок 4 — Контент и правила (Content Layer)
**Цель:** разорвать жёсткую связку “домен импортит `src/data/*`”.

**Подход:**
- собрать контент в один “контейнер” (например, `GameContent`), который создаётся снаружи домена и передаётся внутрь application слоя.
- домен знает только интерфейсы/контракты (например, `SpellDefinition`, `CurseDefinition`), но не знает, откуда они пришли.

**Готово когда:**
- domain больше не импортит `src/data/*`,
- контент можно подменить (для тестов/режимов/баланса).

### Блок 5 — Инфраструктура: Supabase и LocalStorage через адаптеры
**Цель:** вытащить I/O из Zustand/компонентов в инфраструктурный слой с интерфейсами.

**Кандидаты:**
- `wallet`:
  - интерфейс `WalletRepository` (внутренний слой),
  - реализация `SupabaseWalletRepository` (infrastructure),
  - Zustand store становится “тонким”: дергает use‑case/репозиторий, а не содержит SQL‑like логику.
- `templates/history/ui-state`:
  - `TemplateRepository`, `RunHistoryRepository`, `UIStateRepository`
  - реализации `LocalStorage*Repository`

**Готово когда:**
- store’ы не содержат прямых `.from('wallets')...` (или хотя бы это изолировано в одном месте),
- LocalStorage доступ централизован и мокается в тестах.

### Блок 6 — Навигация/композиция и “мета-слой”
**Цель:** привести `App.tsx` к роли composition root + изолировать мета‑слой (dev quest / пасхалки) от game.

**Идея:**
- `App.tsx` оставляем как маршрутизатор/компоновщик, но переносим мета‑эффекты (idle, magic words, overlays) в `features/devquest` и подключаем как отдельный “плагин”.

**Готово когда:**
- геймплей можно запускать/использовать без devquest‑логики (по желанию),
- App меньше знает о деталях конкретных фич.

### Блок 7 — Уборка артефактов
**Цель:** убрать шум из репо.
- `skazmor-app/` пометить как архив (или вынести из рабочего дерева), чтобы не путать новую архитектуру; перед удалением/выносом — подтвердить, что он больше не нужен как “историческая версия”.

---

## 5) Шаблон “мини‑плана” для каждого блока (то, из чего будет состоять 30% этого плана)

Для каждого блока мы создаём отдельный файл в `memory-bank/refactor/blocks/` вида:
`block-XX-<short-name>.md`

**Шаблон:**
- **Цель блока** (1–2 предложения)
- **Scope**: что точно делаем / что точно НЕ делаем
- **Затрагиваемые файлы/папки**
- **Шаги миграции** (маленькими коммит‑порциями)
- **Риски и план отката**
- **Критерии готовности (DoD)**
- **Чеклист регресса** (ручной)
- **Документация**: какие `memory-bank/*` обновляем при необходимости

---

## 6) Правила выполнения рефакторинга (чтобы не ломалось)

- Один блок = один “мини‑план” = одна серия маленьких PR/коммитов.
- После каждого шага внутри блока проект должен собираться и запускаться.
- Любое изменение игровой логики → обновляем `memory-bank/gameMechanics.md`.
- Любое изменение контента → обновляем `memory-bank/gameContent.md`.
- Любые изменения дизайн‑системы/компонентных паттернов → `memory-bank/uiDesign.md`.

---

## 7) Что делаем следующим шагом (V1 → V1.1)

1) Утвердить **целевую структуру папок** (можно с небольшими правками под твой стиль).
2) Создать мини‑план для **Блока 0** (предохранители).
3) Создать мини‑план для **Блока 1** (domain kernel) и начать перенос без изменения поведения.


