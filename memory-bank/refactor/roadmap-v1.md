# Roadmap внедрения рефакторинга (V1)

## Цель документа
Дать практический порядок выполнения блоков рефакторинга: **что делаем первым**, что можно параллелить, где обязательные стоп‑точки и как не “сломать всё сразу”.

Этот roadmap дополняет:
- главный план: `memory-bank/refactor/plan-v1.md`
- мини‑планы блоков: `memory-bank/refactor/blocks/*`

---

## Статус (V1)
**Roadmap V1 полностью выполнен.** Завершены блоки: **0 → 1 → 2 → 2A → 3 → 4 → 5 → 6 → 8 → 90**.

**Последнее обновление:** 2025-12-19.

---

## Принципы выполнения (коротко)
- **Один блок → маленькие шаги → каждый шаг компилируется и запускается.**
- Внутри блока допускаются временные “мосты” (ре‑экспорты), чтобы UI не переписывать массово.
- После каждого завершённого блока делаем чекпойнт: `activeContext.md` + `progress.md`.
- Двигаемся **строго по порядку** блоков, указанному в этом roadmap (без перестановок), если явно не договорились иначе.

---

## Рекомендуемый порядок (основная “колея”)

### Фаза 0 — Подготовка (без изменения поведения)
1) **Блок 0 — Guardrails**  
   `memory-bank/refactor/blocks/block-00-guardrails.md`  
   Результат: правила границ, алиасы импортов (если вводим), минимальные проверки.

**Стоп‑точка:** проект стабильно собирается/запускается, договорённости зафиксированы.

### Фаза 1 — Ядро игры (с минимальными мостами)
2) **Блок 1 — Game Domain Kernel**  
   `memory-bank/refactor/blocks/block-01-game-domain-kernel.md`  
   Результат: доменное ядро вынесено, UI работает через ре‑экспорты.

3) **Блок 2 — Application Layer / GameSession**  
   `memory-bank/refactor/blocks/block-02-game-application-layer.md`  
   + **2A — In‑Game Navigation**  
   `memory-bank/refactor/blocks/block-02a-in-game-navigation.md`  
   Результат: появляется GameSession и внутриигровые экраны (`inGameView`), сессия живёт внутри game‑флоу.

**Стоп‑точка:** можно перейти между внутриигровыми экранами без сброса state; “выход из боя в середине” оформляется use‑case’ом (`exitCombat`).
> Примечание: если в текущем наборе `inGameView` нет экранов, которые реально “уходят из боя в середине” (кроме `pause`), `exitCombat` может быть оставлен как техдолг и добавлен при расширении внутриигровой навигации.

### Фаза 2 — UI становится “конструктором”
4) **Блок 3 — UI декомпозиция `GameScreen`**  
   `memory-bank/refactor/blocks/block-03-game-ui-decomposition.md`  
   Результат: `GameScreen` перестаёт быть монолитом, компоненты переиспользуемы для story/shop/rewards.

**Стоп‑точка:** новые внутриигровые экраны можно собирать без копирования кода из `GameScreen`.

### Фаза 3 — Контент и инфраструктура (развязка зависимостей)
5) **Блок 4 — Content Layer + `GameContent` packs**  
   `memory-bank/refactor/blocks/block-04-content-layer.md`  
   Результат: домен/апп‑слой не импортят `src/data/*` напрямую, контент собирается через `GameContent`.

6) **Блок 5 — Infrastructure adapters (Supabase → затем LocalStorage)**  
   `memory-bank/refactor/blocks/block-05-infrastructure-adapters.md`  
   Результат: I/O вынесен в `infrastructure`, stores/UI вызывают use‑cases.

**Стоп‑точка:** в сторах/компонентах нет прямого Supabase/LocalStorage для мигрированных подсистем.

### Фаза 4 — Composition Root не становится новым монолитом
7) **Блок 6 — Composition Root / Plugins**  
   `memory-bank/refactor/blocks/block-06-composition-root-and-plugins.md`  
   Результат: `App.tsx` тонкий, devquest/оверлеи — как плагины, game‑флоу имеет чёткую границу.

### Фаза “опционально позже”
8) **Блок 8 — RNG/Clock ports**  
   `memory-bank/refactor/blocks/block-08-rng-clock-ports.md`  
   Статус: выполнено — порты `Rng/Clock` внедрены через инъекцию зависимостей, без изменения механики (без seeded/id‑детерминизма).

### Финал — Документация как “истина”
9) **Блок 90 — Memory Bank docs refresh**  
   `memory-bank/refactor/blocks/block-90-memory-bank-docs-refresh.md`
   Статус: выполнено — документация приведена к фактической архитектуре и источникам истины.

---

## Что можно параллелить (если будет желание ускоряться)
- Внутри одной фазы параллелить нежелательно.
- Допустимо параллелить:
  - **Блок 3 (UI декомпозиция)** и частично **Блок 4 (контент)**, если границы уже ясны и не ломают друг друга.
  - **Блок 5 LocalStorage‑часть** можно делать параллельно Supabase‑части, но только если команда большая (иначе лучше последовательно).

---

## Чекпойнты (обязательные)
После каждого блока:
- обновить `memory-bank/activeContext.md`
- обновить `memory-bank/progress.md`
- убедиться, что `memory-bank/tasks.md` отражает актуальные ссылки и “что дальше”

---

## Вопросы, которые всплывут при реализации (и это нормально)
- Как именно `exitCombat` влияет на состояние (что очищаем/что сохраняем).
- Где именно хранить `GameSession` (провайдер/контейнер) в рамках game‑флоу.
- Когда вводить выбор content pack в UI (vs dev‑флаг/через templates).

---

## Протокол “новый агент / новый чат” (handoff) — как продолжать с сохранённого места

### Когда создавать нового агента
Создавай нового агента/чат если:
- контекст текущего чата стал слишком большим,
- хочешь изолировать работу по одному блоку,
- отдаёшь блок другому исполнителю,
- боишься смешать задачи (UI/infra/content одновременно).

### Что обязательно сделать перед передачей (чеклист)
- Обновить чекпойнт: `memory-bank/activeContext.md` и `memory-bank/progress.md`.
- Убедиться, что в `memory-bank/tasks.md` понятно, **какой блок следующий** (и есть ссылка на его `block-XX-*.md`).
- Если внутри блока приняли решения/ответили на вопросы — добавить их в соответствующий `block-XX-*.md` (“Зафиксировано по ответам”).

### Универсальный промт для нового агента (копипаста)
```
Ты — AI coding agent в Cursor. Мы делаем большой рефакторинг Skazmor Playtest под Clean Architecture, маленькими безопасными шагами, без поломок.

ОБЯЗАТЕЛЬНО:
- Следуй порядку блоков из memory-bank/refactor/roadmap-v1.md (строго по порядку).
- Поддерживай документацию: после каждого существенного шага обновляй memory-bank/activeContext.md и memory-bank/progress.md.
- Комментарии, объясняющие архитектуру/логику — на русском (код/имена сущностей — на английском).
- По возможности используй Context7 MCP для актуальной документации библиотек.

Сначала прочитай:
1) memory-bank/activeContext.md
2) memory-bank/progress.md
3) memory-bank/refactor/plan-v1.md
4) memory-bank/refactor/roadmap-v1.md
5) memory-bank/tasks.md

Затем:
- Определи следующий блок по roadmap/tasks.
- Открой соответствующий мини‑план: memory-bank/refactor/blocks/block-XX-*.md
- Выполняй шаги мини‑плана, не добавляя лишнего.

Если не хватает контекста — задай уточняющие вопросы. Апдейты давай коротко и понятно.
```

### Дополнение к промту по отсечкам (после фаз)
Добавляй 2–3 строки к универсальному промту, чтобы агент точно понял фазу:

- **После Фазы 0 (Блок 0 завершён)**:
  - “Блок 0 завершён. Следующее: Блок 1 (domain kernel). Используем ре‑экспорты для плавной миграции.”

- **После Фазы 1 (Блоки 1–2–2A завершены)**:
  - “Есть GameSession и inGameView. Выход из боя возможен в середине (вариант B) и должен быть use‑case’ом exitCombat. Следующее: Блок 3 (UI декомпозиция).”

- **После Фазы 2 (Блок 3 завершён)**:
  - “UI стал сборным. Следующее: Блок 4 (GameContent packs), убрать прямые импорты data из домена.”

- **После Фазы 3 (Блоки 4–5 завершены)**:
  - “Content и Infrastructure готовы. В Блоке 5 шли Supabase: wallet → auth → notes; auth простой. Следующее: Блок 6 (composition root + plugins).”

- **После Фазы 4 (Блок 6 завершён)**:
  - “App тонкий, plugins выделены. Опционально: Блок 8 (Rng/Clock) без seeded/id‑детерминизма. Финал: Блок 90 (ревизия Memory Bank).”


